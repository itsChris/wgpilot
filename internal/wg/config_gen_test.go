package wg

import (
	"strings"
	"testing"
)

func TestGenerateClientConfig_GatewayMode(t *testing.T) {
	params := ClientConfigParams{
		PeerName:        "test-peer",
		PeerPrivateKey:  "client-private-key",
		PeerAddress:     "10.0.0.2/32",
		DNSServers:      "1.1.1.1, 8.8.8.8",
		ServerPublicKey: "server-public-key",
		ServerEndpoint:  "vpn.example.com:51820",
		AllowedIPs:      "0.0.0.0/0, ::/0",
	}

	conf, err := GenerateClientConfig(params)
	if err != nil {
		t.Fatal(err)
	}

	// Verify key sections
	if !strings.Contains(conf, "[Interface]") {
		t.Error("missing [Interface] section")
	}
	if !strings.Contains(conf, "[Peer]") {
		t.Error("missing [Peer] section")
	}

	// Verify content
	if !strings.Contains(conf, "PrivateKey = client-private-key") {
		t.Error("missing PrivateKey")
	}
	if !strings.Contains(conf, "Address = 10.0.0.2/32") {
		t.Error("missing Address")
	}
	if !strings.Contains(conf, "DNS = 1.1.1.1, 8.8.8.8") {
		t.Error("missing DNS")
	}
	if !strings.Contains(conf, "PublicKey = server-public-key") {
		t.Error("missing server PublicKey")
	}
	if !strings.Contains(conf, "AllowedIPs = 0.0.0.0/0, ::/0") {
		t.Error("missing AllowedIPs for gateway mode")
	}
	if !strings.Contains(conf, "Endpoint = vpn.example.com:51820") {
		t.Error("missing Endpoint")
	}
	if !strings.Contains(conf, "# Generated by wgpilot") {
		t.Error("missing header comment")
	}
	if !strings.Contains(conf, "test-peer") {
		t.Error("missing peer name in header")
	}
}

func TestGenerateClientConfig_HubRouted(t *testing.T) {
	params := ClientConfigParams{
		PeerName:        "hub-peer",
		PeerPrivateKey:  "priv-key",
		PeerAddress:     "10.0.0.3/32",
		ServerPublicKey: "server-pub",
		ServerEndpoint:  "1.2.3.4:51820",
		AllowedIPs:      "10.0.0.0/24",
	}

	conf, err := GenerateClientConfig(params)
	if err != nil {
		t.Fatal(err)
	}

	if !strings.Contains(conf, "AllowedIPs = 10.0.0.0/24") {
		t.Error("hub-routed should use subnet as AllowedIPs")
	}
	// DNS should not appear if empty
	if strings.Contains(conf, "DNS") {
		t.Error("DNS should not appear when empty")
	}
}

func TestGenerateClientConfig_WithPresharedKey(t *testing.T) {
	params := ClientConfigParams{
		PeerName:        "psk-peer",
		PeerPrivateKey:  "priv-key",
		PeerAddress:     "10.0.0.4/32",
		ServerPublicKey: "server-pub",
		PresharedKey:    "preshared-secret-key",
		ServerEndpoint:  "1.2.3.4:51820",
		AllowedIPs:      "0.0.0.0/0",
	}

	conf, err := GenerateClientConfig(params)
	if err != nil {
		t.Fatal(err)
	}

	if !strings.Contains(conf, "PresharedKey = preshared-secret-key") {
		t.Error("missing PresharedKey")
	}
}

func TestGenerateClientConfig_WithKeepalive(t *testing.T) {
	params := ClientConfigParams{
		PeerName:            "keepalive-peer",
		PeerPrivateKey:      "priv-key",
		PeerAddress:         "10.0.0.5/32",
		ServerPublicKey:     "server-pub",
		ServerEndpoint:      "1.2.3.4:51820",
		AllowedIPs:          "0.0.0.0/0",
		PersistentKeepalive: 25,
	}

	conf, err := GenerateClientConfig(params)
	if err != nil {
		t.Fatal(err)
	}

	if !strings.Contains(conf, "PersistentKeepalive = 25") {
		t.Error("missing PersistentKeepalive")
	}
}

func TestGenerateClientConfig_NoKeepalive(t *testing.T) {
	params := ClientConfigParams{
		PeerName:        "no-keepalive",
		PeerPrivateKey:  "priv-key",
		PeerAddress:     "10.0.0.6/32",
		ServerPublicKey: "server-pub",
		ServerEndpoint:  "1.2.3.4:51820",
		AllowedIPs:      "0.0.0.0/0",
	}

	conf, err := GenerateClientConfig(params)
	if err != nil {
		t.Fatal(err)
	}

	if strings.Contains(conf, "PersistentKeepalive") {
		t.Error("PersistentKeepalive should not appear when 0")
	}
}

func TestGenerateClientConfig_NoPresharedKey(t *testing.T) {
	params := ClientConfigParams{
		PeerName:        "no-psk",
		PeerPrivateKey:  "priv-key",
		PeerAddress:     "10.0.0.7/32",
		ServerPublicKey: "server-pub",
		ServerEndpoint:  "1.2.3.4:51820",
		AllowedIPs:      "0.0.0.0/0",
	}

	conf, err := GenerateClientConfig(params)
	if err != nil {
		t.Fatal(err)
	}

	if strings.Contains(conf, "PresharedKey") {
		t.Error("PresharedKey should not appear when empty")
	}
}

func TestGenerateClientConfig_MissingRequired(t *testing.T) {
	tests := []struct {
		name   string
		params ClientConfigParams
	}{
		{
			"missing private key",
			ClientConfigParams{ServerPublicKey: "pub", ServerEndpoint: "1:2", AllowedIPs: "0.0.0.0/0"},
		},
		{
			"missing server public key",
			ClientConfigParams{PeerPrivateKey: "priv", ServerEndpoint: "1:2", AllowedIPs: "0.0.0.0/0"},
		},
		{
			"missing endpoint",
			ClientConfigParams{PeerPrivateKey: "priv", ServerPublicKey: "pub", AllowedIPs: "0.0.0.0/0"},
		},
		{
			"missing allowed ips",
			ClientConfigParams{PeerPrivateKey: "priv", ServerPublicKey: "pub", ServerEndpoint: "1:2"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := GenerateClientConfig(tt.params)
			if err == nil {
				t.Error("expected error for missing required field")
			}
		})
	}
}

func TestComputeClientAllowedIPs(t *testing.T) {
	tests := []struct {
		mode         string
		subnet       string
		siteNetworks string
		expected     string
	}{
		{"gateway", "10.0.0.0/24", "", "0.0.0.0/0, ::/0"},
		{"hub-routed", "10.0.0.0/24", "", "10.0.0.0/24"},
		{"site-to-site", "10.0.0.0/24", "192.168.1.0/24, 192.168.2.0/24", "192.168.1.0/24, 192.168.2.0/24"},
		{"site-to-site", "10.0.0.0/24", "", "10.0.0.0/24"},
		{"unknown", "10.0.0.0/24", "", "0.0.0.0/0, ::/0"},
	}

	for _, tt := range tests {
		t.Run(tt.mode, func(t *testing.T) {
			got := ComputeClientAllowedIPs(tt.mode, tt.subnet, tt.siteNetworks)
			if got != tt.expected {
				t.Errorf("ComputeClientAllowedIPs(%q, %q, %q) = %q, want %q",
					tt.mode, tt.subnet, tt.siteNetworks, got, tt.expected)
			}
		})
	}
}

func TestGenerateClientConfig_ValidSyntax(t *testing.T) {
	params := ClientConfigParams{
		PeerName:            "full-config",
		PeerPrivateKey:      "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
		PeerAddress:         "10.0.0.2/32",
		DNSServers:          "1.1.1.1",
		ServerPublicKey:     "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=",
		PresharedKey:        "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC=",
		ServerEndpoint:      "vpn.example.com:51820",
		AllowedIPs:          "0.0.0.0/0, ::/0",
		PersistentKeepalive: 25,
	}

	conf, err := GenerateClientConfig(params)
	if err != nil {
		t.Fatal(err)
	}

	// Verify valid WireGuard config syntax: must have [Interface] before [Peer]
	ifaceIdx := strings.Index(conf, "[Interface]")
	peerIdx := strings.Index(conf, "[Peer]")
	if ifaceIdx == -1 || peerIdx == -1 {
		t.Fatal("missing required sections")
	}
	if ifaceIdx >= peerIdx {
		t.Error("[Interface] must come before [Peer]")
	}

	// Check lines are properly formatted (Key = Value)
	lines := strings.Split(conf, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "[") {
			continue
		}
		if !strings.Contains(line, " = ") {
			t.Errorf("invalid config line format: %q", line)
		}
	}
}
