package wg

import (
	"bytes"
	"fmt"
	"text/template"
)

var clientConfigTmpl = template.Must(template.New("client_config").Parse(
	`# Generated by wgpilot â€” {{ .PeerName }}
[Interface]
PrivateKey = {{ .PeerPrivateKey }}
Address = {{ .PeerAddress }}
{{- if .DNSServers }}
DNS = {{ .DNSServers }}
{{- end }}

[Peer]
PublicKey = {{ .ServerPublicKey }}
{{- if .PresharedKey }}
PresharedKey = {{ .PresharedKey }}
{{- end }}
AllowedIPs = {{ .AllowedIPs }}
Endpoint = {{ .ServerEndpoint }}
{{- if gt .PersistentKeepalive 0 }}
PersistentKeepalive = {{ .PersistentKeepalive }}
{{- end }}
`))

// GenerateClientConfig produces a WireGuard .conf file from the given parameters.
func GenerateClientConfig(params ClientConfigParams) (string, error) {
	if params.PeerPrivateKey == "" {
		return "", fmt.Errorf("generate client config: peer private key is required")
	}
	if params.ServerPublicKey == "" {
		return "", fmt.Errorf("generate client config: server public key is required")
	}
	if params.ServerEndpoint == "" {
		return "", fmt.Errorf("generate client config: server endpoint is required")
	}
	if params.AllowedIPs == "" {
		return "", fmt.Errorf("generate client config: allowed IPs is required")
	}

	var buf bytes.Buffer
	if err := clientConfigTmpl.Execute(&buf, params); err != nil {
		return "", fmt.Errorf("generate client config: %w", err)
	}
	return buf.String(), nil
}

// ComputeClientAllowedIPs determines the AllowedIPs for a client config
// based on the network mode and configuration.
func ComputeClientAllowedIPs(mode, subnet, siteNetworks string) string {
	switch mode {
	case "gateway":
		return "0.0.0.0/0, ::/0"
	case "hub-routed":
		return subnet
	case "site-to-site":
		if siteNetworks != "" {
			return siteNetworks
		}
		return subnet
	default:
		return "0.0.0.0/0, ::/0"
	}
}
